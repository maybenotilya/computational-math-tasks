# Задача 1. Библиотека OpenMP

Давайте рассмотрим книгу В. П. Гергеля “Высокопроизводительные вычисления для
многоядерных многопроцессорных систем” (2010). В главе 11 "Решение
дифференциальных уравнений в частных производных", описывающей проблему
численного решения задачи Дирихле для уравнения Пуассона, содержится алгоритм
11.6 (Блочный подход к методу волновой обработки данных) её решения, который
может быть эффективно распараллелен при помощи OpenMP.
В первой части задания вам следует просто разобраться в этом алгоритме и
реализовать его. Обратите внимание, что он возникает итерационно. Например,
алгоритм 11.2 является корректным, но распараллеливание приводит к замедлению в
25 раз вместо ускорения.
Вторая часть задания — провести численный эксперимент, исследующий
эффективность (или неэффективность) параллельной версии. Модельные краевые
задачи необходимо выбрать самостоятельно, исходя из того, что вы хотели бы теми
или иными экспериментами продемонстрировать. Это наиболее сложная часть
задания.

# Теория
Рассмотрим сетку размером `NB x NB` блоков. Посчитаем, сколько "шагов" нужно для обработки всех блоков во время одной итерации.
* Последовательный алгоритм. Очевидно, придется обработать каждый блок, поэтому потребуется `NB * NB` шагов.
* Параллельный алгоритм. Пусть алгоритм исполняется на `nthreads` потоках. Во время параллельного исполнения за один шаг может обрабатываться вплоть до `nthreads` блоков, но только в рамках одной волны. Таким образом, потребуется $2\displaystyle\sum_{i = 1}^{NB - 1} ceil(i / nthreads) + ceil(NB / nthreads)$.

Тогда рассмотрим ускорения (буз учета других затрат, таких как синхронизация и тд.) для некоторых значений `NB` при значениях `nthreads = 4` и `nthreads = 8`:

|   NB  | Ускорение для 4 потоков | Ускорение для 8 потоков |
|-------|-------------------------|-------------------------|
|   2   |       1.33              |           1.33          |
|   4   |       2.27              |           2.29          |
|   8   |       2.90              |           4.27          |
|   16  |       3.39              |           5.57          |

# Эксперимент

Рассмотрим фиксированные размер сетки `N = 1024`, порог вычисления ошибки `eps = 0.1` и размеры блоков `block_size`, равные 205, 128 и 64 (им отвечают `NB`, равные 5, 8 и 16 соответственно).

В качестве модельных задач рассмотрим две: 
* Задачу из книги
    * $f(x, y) = 0$
    * $g(x, y) = $

        $100 - 200x, ~y = 0$

        $100 - 200y, ~x = 0$

        $-100 + 200x, ~y = 1$

        $-100 + 200y, ~x = 1$

* Задачу 1
    * $f(x, y) = \dfrac{5000}{xy}$
    * $g(x, y) = 100x^2 + 200y^3$

Задачи выбирались исходя из количества итераций, необходимых для приближения с заданной точностью.

Ниже преведены таблицы с замерами времени исполнения алгоритма на заданных параметрах и с отношением реального ускорения с теоретическим. Каждое значение времени считалось как среднее пяти измерений.

Измерения проводились на CPU Intel Core i5-12500H × 16

## Таблицы для функции с книги:

|Размер блока|NB|Итерации|Время, 1 поток|Время, 4 потока|Время, 8 потоков|Ускорение, 4 потока|Ускорение, 8 потоков| 
|------------|--|--------|--------------|---------------|----------------|-------------------|--------------------|
|     64     |16|    353 |     1210 ms  |     394 ms    |    409 ms      |      3.07         |        2.96        |
|    128     | 8|    353 |     1221 ms  |     467 ms    |    393 ms      |      2.61         |        3.11        |
|    256     | 4|    353 |     1134 ms  |     529 ms    |    653 ms      |      2.14         |        1.74        |
|    512     | 2|    353 |     1108 ms  |     890 ms    |    910 ms      |      1.24         |        1.22        |

| NB | Отношение для 4 потоков | Отношение для 8 потоков |
|----|-------------------------|-------------------------|
| 2  |        0.93             |          0.92           |
| 4  |        0.94             |          0.76           |
| 8  |        0.90             |          0.73           |
| 16 |        0.91             |          0.53           |


## Таблица для модельной функции:

|Размер блока|NB|Итерации|Время, 1 поток|Время, 4 потока|Время, 8 потоков|Ускорение, 4 потока|Ускорение, 8 потоков| 
|------------|--|--------|--------------|---------------|----------------|-------------------|--------------------|
|     64     |16|   14496|  43990 ms    |    13326 ms   |  11877 ms      |      3.30         |        3.70        |
|    128     |8 |   14496|  42819 ms    |    15042 ms   |  14051 ms      |      2.65         |        3.05        |
|    256     |4 |   14496|  43404 ms    |    20638 ms   |  23995 ms      |      2.10         |        1.81        |
|    512     |2 |   14496|  42755 ms    |    33711 ms   |  38871 ms      |      1.27         |        1.10        |

| NB | Отношение для 4 потоков | Отношение для 8 потоков |
|----|-------------------------|-------------------------|
| 2  |        0.95             |        0.83             |
| 4  |        0.93             |        0.80             |
| 8  |        0.91             |        0.71             |
| 16 |        0.97             |        0.66             |

# Выводы

1. Уменьшение размера блока (и, соответственно, увеличение `NB`) положительно сказывается на уменьшении времени работы параллельного алгоритма относительно последовательного. При этом нельзя допускать сильного уменьшения блока, так как тогда алгоритм перестанет быть блочным и кэши процессора будут использоваться значительно хуже.

2. Чем больший блок обрабатывается в одном потоке, тем большее ускорение относительно ожидаемого максимума распаралеливание даст. Объяснить это можно тем, что при увеличении размера блока процент времени, затрачиваемого на синхронизацию потоков, относилельно полезного времени работы будет становиться всё меньше и меньше.

3. В среднем отличие скорости работы на 4 и на 8 потоках незначительные и находятся в пределах погрешности. 

4. Относительно максимально возможного ускорения, 4 потока показывают более стабтльные и высокие результаты, нежели 8 потоков. Во время экспериментов встречались результаты, на которых время работы 8 потоков даже превышало последовательную версию.

Подобные результаты можно обосновать тем, что при работе с 8 потоками затраты на их синхронизацию выше, чем при работе с 4 потоками. Это приводит к тому, что на большем количестве итераций эти затраты занимают кратно больше времени, что нивелирует пользу от распараллеливания (а иногда и перевешивает, что приводит вообще к замедлению программы). Также к таким результатом могут привести другие процессы, запущенные на машине, которым тоже необходимо выделять процессорное время. В таком сценарии 4 потока также будут эффективнее, так как требуют меньше ресурсов компьютера.
